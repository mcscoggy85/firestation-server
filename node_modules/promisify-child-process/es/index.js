
import child_process from 'child_process';

export function promisifyChildProcess(child, options = {}) {
  const _promise = new Promise((resolve, reject) => {
    let stdout, stderr;
    if (options.encoding && options.encoding !== 'buffer') {
      stdout = child.stdout ? '' : null, stderr = child.stderr ? '' : null;
      if (stdout != null) child.stdout.on('data', data => stdout += data);
      if (stderr != null) child.stderr.on('data', data => stderr += data);
    } else {
      stdout = child.stdout ? Buffer.alloc(0) : null, stderr = child.stderr ? Buffer.alloc(0) : null;
      if (stdout != null) child.stdout.on('data', data => stdout = Buffer.concat([stdout, data]));
      if (stderr != null) child.stderr.on('data', data => stderr = Buffer.concat([stderr, data]));
    }
    child.on('error', reject);
    function done(code, signal) {
      let error;
      if (code != null && code !== 0) error = new Error(`Process exited with code ${code}`);else if (signal != null) error = new Error(`Process was killed with ${signal}`);
      if (error) {
        if (code != null) error.code = code;
        if (signal != null) error.signal = signal;
        error.stdout = stdout;
        error.stderr = stderr;
        reject(error);
      } else {
        resolve({ stdout, stderr });
      }
    }
    child.on('close', done);
    child.on('exit', done);
  });
  return Object.create(child, {
    then: { value: _promise.then.bind(_promise) },
    catch: { value: _promise.catch.bind(_promise) }
  });
}

export function spawn(command, args, options) {
  return promisifyChildProcess(child_process.spawn(command, args, options), Array.isArray(args) ? options : args);
}

export function fork(module, args, options) {
  return promisifyChildProcess(child_process.fork(module, args, options), Array.isArray(args) ? options : args);
}

function promisifyExecMethod(method) {
  return (...args) => {
    let child;
    const _promise = new Promise((resolve, reject) => {
      child = method(...args, (err, stdout, stderr) => {
        if (err) {
          err.stdout = stdout;
          err.stderr = stderr;
          reject(err);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
    if (!child) throw new Error("unexpected error: child has not been initialized");
    return Object.create(child, {
      then: { value: _promise.then.bind(_promise) },
      catch: { value: _promise.catch.bind(_promise) }
    });
  };
}

export const exec = promisifyExecMethod(child_process.exec);

export const execFile = promisifyExecMethod(child_process.execFile);